This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/

Student ID: SLAE-670

Problem:
•	Create a custom crypter like the one shown in the “crypters” video
•	Free to use any existing encryption schema
•	Can use any programming language

Solution:

In this post I am going to show you an example implementation of a crypter. In this particular case, I will be using C to demo the PoC with a pre-generated execve shellcode and the Rijndael-128 cipher in CBC mode for encryption. To avoid having to implement the cipher myself, I will be making use of the MCRYPT encryption and decryption functions.

To complete the assignment, two general parts must be implemented: 1) the crypter; and 2) the decrypter. We begin with the crypter:

<CRYPTER SOURCE CODE>

Summarizing the execution flow, the crypter first asks for an encryption key, and then uses that key along with a randomly generated initialization vector to encrypt the original execve shellcode. Finally, the program proceeds to write and compile a decrypter file, which upon execution will use the key and the initialization vector to decrypt and execute the original shellcode:

 

The C template generated by the crypter has the following format:

<A7-DECRYPT-TEMPLATE.C>

Which is basically the shorter, not error-checked version of the decrypter:

<DECRYPTER-SOURCE CODE>

To properly decrypt the shellcode, the decrypter must have the correct key and initialization vector. Both of these are passed as part of the vector variable, which is nothing but a concatenation of the key and the random initialization vector generated by the crypter. 
The decrypter then works by splitting reading both values from the vector, and using them to decrypt the shellcode. Finally, the decrypted shellcode is executed.

Limitations and Discussion:
Using a key of 4 characters may produce bad encryption results, causing the decrypter to crash with a Segmentation Fault or an Illegal Instruction message. The crypter implementation presented in this blog post forces at least 7 characters to be used.

The crypter supports very basic bad character checking, only looking out for 0x00, 0x0a, and 0x0d. This list can of course be easily expanded. Alternatively, an additional encoder could be added.

The crypter uses a Rijndael-128 CBC cipher. This functionality should easily be modifiable by changing the mcrypt function call parameters. 
